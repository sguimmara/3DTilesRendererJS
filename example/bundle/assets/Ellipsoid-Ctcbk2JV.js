import{i as P,at as W,l as h,k as B,d as K,ad as Q,bp as tt}from"./three.module-e-akeimH.js";const M=new W,X=new h,it={};function et(r){const{x:t,y:i,z:e}=r;r.x=e,r.y=t,r.z=i}function ot(r){return-(r-Math.PI/2)}function H(r){return-r+Math.PI/2}function st(r,t,i={}){return M.theta=t,M.phi=H(r),X.setFromSpherical(M),M.setFromVector3(X),i.lat=ot(M.phi),i.lon=M.theta,i}function Y(r,t="E",i="W"){const e=r<0?i:t;r=Math.abs(r);const s=~~r,o=(r-s)*60,n=~~o,d=~~((o-n)*60);return`${s}° ${n}' ${d}" ${e}`}function ct(r,t,i=!1){const e=st(r,t,it);let s,o;return i?(s=`${(P.RAD2DEG*e.lat).toFixed(4)}°`,o=`${(P.RAD2DEG*e.lon).toFixed(4)}°`):(s=Y(P.RAD2DEG*e.lat,"N","S"),o=Y(P.RAD2DEG*e.lon,"E","W")),`${s} ${o}`}const Z=new W,m=new h,l=new h,N=new h,p=new B,u=new B,T=new K,a=new tt,G=new h,b=new h,U=new h,R=new h,V=new Q,nt=1e-12,rt=.1,D=0,L=1,O=2;class lt{constructor(t=1,i=1,e=1){this.name="",this.radius=new h(t,i,e)}intersectRay(t,i){return p.makeScale(...this.radius).invert(),T.center.set(0,0,0),T.radius=1,V.copy(t).applyMatrix4(p),V.intersectSphere(T,i)?(p.makeScale(...this.radius),i.applyMatrix4(p),i):null}getEastNorthUpFrame(t,i,e){return this.getEastNorthUpAxes(t,i,G,b,U,R),e.makeBasis(G,b,U).setPosition(R)}getEastNorthUpAxes(t,i,e,s,o,n=R){this.getCartographicToPosition(t,i,0,n),this.getCartographicToNormal(t,i,o),e.set(-n.y,n.x,0).normalize(),s.crossVectors(o,e).normalize()}getAzElRollFromRotationMatrix(t,i,e,s,o=D){return o===L?(a.set(-Math.PI/2,0,0,"XYZ"),u.makeRotationFromEuler(a).premultiply(e)):o===O?(a.set(-Math.PI/2,0,Math.PI,"XYZ"),u.makeRotationFromEuler(a).premultiply(e)):u.copy(e),this.getEastNorthUpFrame(t,i,p).invert(),u.premultiply(p),a.setFromRotationMatrix(u,"ZXY"),s.azimuth=-a.z,s.elevation=a.x,s.roll=a.y,s}getRotationMatrixFromAzElRoll(t,i,e,s,o,n,c=D){return this.getEastNorthUpFrame(t,i,p),a.set(s,o,-e,"ZXY"),n.makeRotationFromEuler(a).premultiply(p).setPosition(0,0,0),c===L?(a.set(Math.PI/2,0,0,"XYZ"),u.makeRotationFromEuler(a),n.multiply(u)):c===O&&(a.set(-Math.PI/2,0,Math.PI,"XYZ"),u.makeRotationFromEuler(a),n.multiply(u)),n}getFrame(t,i,e,s,o,n,c,d=D){return this.getRotationMatrixFromAzElRoll(t,i,e,s,o,c,d),this.getCartographicToPosition(t,i,n,R),c.setPosition(R),c}getCartographicToPosition(t,i,e,s){this.getCartographicToNormal(t,i,m);const o=this.radius;l.copy(m),l.x*=o.x**2,l.y*=o.y**2,l.z*=o.z**2;const n=Math.sqrt(m.dot(l));return l.divideScalar(n),s.copy(l).addScaledVector(m,e)}getPositionToCartographic(t,i){this.getPositionToSurfacePoint(t,l),this.getPositionToNormal(t,m);const e=N.subVectors(t,l);return i.lon=Math.atan2(m.y,m.x),i.lat=Math.asin(m.z),i.height=Math.sign(e.dot(t))*e.length(),i}getCartographicToNormal(t,i,e){return Z.set(1,H(t),i),e.setFromSpherical(Z).normalize(),et(e),e}getPositionToNormal(t,i){const e=this.radius;return i.copy(t),i.x/=e.x**2,i.y/=e.y**2,i.z/=e.z**2,i.normalize(),i}getPositionToSurfacePoint(t,i){const e=this.radius,s=1/e.x**2,o=1/e.y**2,n=1/e.z**2,c=t.x*t.x*s,d=t.y*t.y*o,f=t.z*t.z*n,v=c+d+f,F=Math.sqrt(1/v),z=l.copy(t).multiplyScalar(F);if(v<rt)return isFinite(F)?i.copy(z):null;const j=N.set(z.x*s*2,z.y*o*2,z.z*n*2);let S=(1-F)*t.length()/(.5*j.length()),C=0,_,q,y,E,x,g,w,A,$,k,I;do{S-=C,y=1/(1+S*s),E=1/(1+S*o),x=1/(1+S*n),g=y*y,w=E*E,A=x*x,$=g*y,k=w*E,I=A*x,_=c*g+d*w+f*A-1,q=c*$*s+d*k*o+f*I*n;const J=-2*q;C=_/J}while(Math.abs(_)>nt);return i.set(t.x*y,t.y*E,t.z*x)}calculateHorizonDistance(t,i){const e=this.calculateEffectiveRadius(t);return Math.sqrt(2*e*i+i**2)}calculateEffectiveRadius(t){const i=this.radius.x,s=1-this.radius.z**2/i**2,o=t*P.DEG2RAD,n=Math.sin(o)**2;return i/Math.sqrt(1-s*n)}getPositionElevation(t){this.getPositionToSurfacePoint(t,l);const i=N.subVectors(t,l);return Math.sign(i.dot(t))*i.length()}copy(t){return this.radius.copy(t.radius),this}clone(){return new this.constructor().copy(this)}}export{L as C,lt as E,O,ct as t};
