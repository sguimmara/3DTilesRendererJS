import{g as lt,ag as ht,b as pt,V as S,ad as G,k as nt,l as y,aI as dt,R as ut,s as mt,au as rt,Q as at,i as ft}from"./three.module-e-akeimH.js";class Pt extends lt{constructor(){super(new ht(0,0),new gt),this.renderOrder=1/0}onBeforeRender(t){const e=this.material.uniforms;t.getSize(e.resolution.value)}updateMatrixWorld(){this.matrixWorld.makeTranslation(this.position)}dispose(){this.geometry.dispose(),this.material.dispose()}}class gt extends pt{constructor(){super({depthWrite:!1,depthTest:!1,transparent:!0,uniforms:{resolution:{value:new S},size:{value:15},thickness:{value:2},opacity:{value:1}},vertexShader:`

				uniform float pixelRatio;
				uniform float size;
				uniform float thickness;
				uniform vec2 resolution;
				varying vec2 vUv;

				void main() {

					vUv = uv;

					float aspect = resolution.x / resolution.y;
					vec2 offset = uv * 2.0 - vec2( 1.0 );
					offset.y *= aspect;

					vec4 screenPoint = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
					screenPoint.xy += offset * ( size + thickness ) * screenPoint.w / resolution.x;

					gl_Position = screenPoint;

				}
			`,fragmentShader:`

				uniform float size;
				uniform float thickness;
				uniform float opacity;

				varying vec2 vUv;
				void main() {

					float ht = 0.5 * thickness;
					float planeDim = size + thickness;
					float offset = ( planeDim - ht - 2.0 ) / planeDim;
					float texelThickness = ht / planeDim;

					vec2 vec = vUv * 2.0 - vec2( 1.0 );
					float dist = abs( length( vec ) - offset );
					float fw = fwidth( dist ) * 0.5;
					float a = smoothstep( texelThickness - fw, texelThickness + fw, dist );

					gl_FragColor = vec4( 1, 1, 1, opacity * ( 1.0 - a ) );

				}
			`})}}const Y=new S,$=new S;class yt{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new S,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new S,this.hoverSet=!1}updateFrame(){const{previousPositions:t,pointerPositions:e}=this;for(const i in e)t[i].copy(e[i])}setHoverEvent(t){(t.pointerType==="mouse"||t.type==="wheel")&&(this.getAdjustedPointer(t,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(t){return this.pointerType!==null?(this.getCenterPoint(t),t):this.hoverSet?(t.copy(this.hoverPosition),t):null}getAdjustedPointer(t,e){const o=(this.domElement?this.domElement:t.target).getBoundingClientRect(),n=t.clientX-o.left,l=t.clientY-o.top;e.set(n,l)}addPointer(t){const e=t.pointerId,i=new S;this.getAdjustedPointer(t,i),this.pointerOrder.push(e),this.pointerPositions[e]=i,this.previousPositions[e]=i.clone(),this.startPositions[e]=i.clone(),this.getPointerCount()===1&&(this.pointerType=t.pointerType,this.buttons=t.buttons)}updatePointer(t){const e=t.pointerId;return e in this.pointerPositions?(this.getAdjustedPointer(t,this.pointerPositions[e]),!0):!1}deletePointer(t){const e=t.pointerId,i=this.pointerOrder;i.splice(i.indexOf(e),1),delete this.pointerPositions[e],delete this.previousPositions[e],delete this.startPositions[e],this.getPointerCount.length===0&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(t,e=this.pointerPositions){const i=this.pointerOrder;if(this.getPointerCount()===1||this.getPointerType()==="mouse"){const o=i[0];return t.copy(e[o]),t}else if(this.getPointerCount()===2){const o=this.pointerOrder[0],n=this.pointerOrder[1],l=e[o],a=e[n];return t.addVectors(l,a).multiplyScalar(.5),t}return null}getPreviousCenterPoint(t){return this.getCenterPoint(t,this.previousPositions)}getStartCenterPoint(t){return this.getCenterPoint(t,this.startPositions)}getMoveDistance(){return this.getCenterPoint(Y),this.getPreviousCenterPoint($),Y.sub($).length()}getTouchPointerDistance(t=this.pointerPositions){if(this.getPointerCount()<=1||this.getPointerType()==="mouse")return 0;const{pointerOrder:e}=this,i=e[0],o=e[1],n=t[i],l=t[o];return n.distanceTo(l)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return this.getPointerType()==="touch"}getPointerButtons(){return this.buttons}isLeftClicked(){return!!(this.buttons&1)}isRightClicked(){return!!(this.buttons&2)}}const w=new nt,K=new G,N=new y;function L(m,t,e){return e.makeTranslation(-m.x,-m.y,-m.z),w.makeRotationFromQuaternion(t),e.premultiply(w),w.makeTranslation(m.x,m.y,m.z),e.premultiply(w),e}function E(m,t,e,i){i.x=(m-e.offsetLeft)/e.clientWidth*2-1,i.y=-((t-e.offsetTop)/e.clientHeight)*2+1,i.isVector3&&(i.z=0)}function St(m,t,e){return t.intersectRay(m,e)?e:(w.makeScale(...t.radius).invert(),K.copy(m).applyMatrix4(w),N.set(0,0,0),K.closestPointToPoint(N,e).normalize(),w.makeScale(...t.radius),e.applyMatrix4(w))}function _t(m,t,e){const i=m.origin.length(),o=Math.acos(t/i);e.copy(m.origin).multiplyScalar(-1).normalize();const n=N.crossVectors(e,m.direction).normalize();e.multiplyScalar(-1).applyAxisAngle(n,-o).normalize().multiplyScalar(t)}function z(m,t,e){const i=m instanceof G?m:m.ray,{origin:o,direction:n}=i;o.set(t.x,t.y,-1).unproject(e),n.set(t.x,t.y,1).unproject(e).sub(o),m.isRay||(m.near=0,m.far=n.length(),m.camera=e),n.normalize()}const b=0,k=1,T=2,O=3,H=4,Z=.05,j=.025,C=new nt,x=new y,d=new y,U=new y,X=new y,R=new y,M=new at,J=new rt,v=new y,V=new y,q=new y,vt=new at,u=new G,A=new S,g=new S,tt=new S,F=new S,B=new S,et=new S,it={type:"change"},ot={type:"start"},st={type:"end"};class Dt extends dt{get enabled(){return this._enabled}set enabled(t){t!==this.enabled&&(this._enabled=t,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(t=null,e=null,i=null,o=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.reorientOnDrag=!0,this.scaleZoomOrientationAtEdges=!1,this.state=b,this.pointerTracker=new yt,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new y,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new y,this.zoomPoint=new y,this.zoomDelta=0,this.rotationInertiaPivot=new y,this.rotationInertia=new S,this.dragInertia=new y,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new Pt,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new ut,this.raycaster.firstHitOnly=!0,this.up=new y(0,1,0),this.clock=new mt,this.fallbackPlane=new rt(new y(0,1,0),0),this.useFallbackPlane=!0,this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=b,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,i&&this.attach(i),e&&this.setCamera(e),t&&this.setScene(t),o&&this.setTilesRenderer(o)}setScene(t){this.scene=t}setCamera(t){this.camera=t,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=t,this.resetState()}setTilesRenderer(t){this.tilesRenderer&&this.tilesRenderer.removeEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.tilesRenderer=t,this.tilesRenderer!==null&&(this.tilesRenderer.addEventListener("tile-visibility-change",this._tilesOnChangeCallback),this.scene===null&&this.setScene(this.tilesRenderer.group))}attach(t){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=t,this.pointerTracker.domElement=t,t.style.touchAction="none";const e=s=>{s.preventDefault()},i=s=>{s.preventDefault();const{camera:p,raycaster:h,domElement:r,up:_,pivotMesh:f,pointerTracker:c,scene:D,pivotPoint:I,enabled:ct}=this;if(c.addPointer(s),this.needsUpdate=!0,c.isPointerTouch()){if(f.visible=!1,c.getPointerCount()===0)r.setPointerCapture(s.pointerId);else if(c.getPointerCount()>2){this.resetState();return}}c.getCenterPoint(g),E(g.x,g.y,r,g),z(h,g,p);const Q=Math.abs(h.ray.direction.dot(_));if(Q<Z||Q<j)return;const W=this._raycast(h);W&&(c.getPointerCount()===2||c.isRightClicked()||c.isLeftClicked()&&s.shiftKey?(this.setState(c.isPointerTouch()?H:T),I.copy(W.point),f.position.copy(W.point),f.visible=c.isPointerTouch()?!1:ct,f.updateMatrixWorld(),D.add(f)):c.isLeftClicked()&&(this.setState(k),I.copy(W.point),f.position.copy(W.point),f.updateMatrixWorld(),D.add(f)))};let o=!1;const n=s=>{s.preventDefault();const{pivotMesh:p,enabled:h}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.state!==b&&(this.needsUpdate=!0);const{pointerTracker:r}=this;r.setHoverEvent(s),r.updatePointer(s)&&(r.isPointerTouch()&&r.getPointerCount()===2&&(o||(o=!0,queueMicrotask(()=>{o=!1,r.getCenterPoint(B);const _=r.getStartTouchPointerDistance(),f=r.getTouchPointerDistance(),c=f-_;if(this.state===b||this.state===H){r.getCenterPoint(B),r.getStartCenterPoint(et);const D=2*window.devicePixelRatio,I=B.distanceTo(et);(Math.abs(c)>D||I>D)&&(Math.abs(c)>I?(this.setState(O),this.zoomDirectionSet=!1):this.setState(T))}if(this.state===O){const D=r.getPreviousTouchPointerDistance();this.zoomDelta+=f-D,p.visible=!1}else this.state===T&&(p.visible=h)}))),this.dispatchEvent(it))},l=s=>{const{pointerTracker:p}=this;p.deletePointer(s),p.getPointerType()==="touch"&&p.getPointerCount()===0&&t.releasePointerCapture(s.pointerId),this.resetState(),this.needsUpdate=!0},a=s=>{s.preventDefault();const{pointerTracker:p}=this;p.setHoverEvent(s),p.updatePointer(s),this.dispatchEvent(ot);let h;switch(s.deltaMode){case 2:h=s.deltaY*800;break;case 1:h=s.deltaY*40;break;case 0:h=s.deltaY;break}const r=Math.sign(h),_=Math.abs(h);this.zoomDelta-=.25*r*_,this.needsUpdate=!0,this._lastUsedState=O,this.dispatchEvent(st)},P=s=>{const{pointerTracker:p}=this;s.buttons!==p.getPointerButtons()&&(p.deletePointer(s),this.resetState())};t.addEventListener("contextmenu",e),t.addEventListener("pointerdown",i),t.addEventListener("pointermove",n),t.addEventListener("pointerup",l),t.addEventListener("wheel",a,{passive:!1}),t.addEventListener("pointerenter",P),this._detachCallback=()=>{t.removeEventListener("contextmenu",e),t.removeEventListener("pointerdown",i),t.removeEventListener("pointermove",n),t.removeEventListener("pointerup",l),t.removeEventListener("wheel",a),t.removeEventListener("pointerenter",P)}}getUpDirection(t,e){e.copy(this.up)}getCameraUpDirection(t){this.getUpDirection(this.camera.position,t)}getPivotPoint(t){let e=null;this._lastUsedState===O?this._zoomPointWasSet&&(e=t.copy(this.zoomPoint)):(this._lastUsedState===T||this._lastUsedState===k)&&(e=t.copy(this.pivotPoint));const{camera:i,raycaster:o}=this;e!==null&&(d.copy(e).project(i),(d.x<-1||d.x>1||d.y<-1||d.y>1)&&(e=null)),z(o,{x:0,y:0},i);const n=this._raycast(o);return n&&(e===null||n.distance<e.distanceTo(o.ray.origin))&&(e=t.copy(n.point)),e}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}resetState(){this.state!==b&&this.dispatchEvent(st),this.state=b,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0}setState(t=this.state,e=!0){this.state!==t&&(this.state===b&&e&&this.dispatchEvent(ot),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=t,t!==b&&t!==H&&(this._lastUsedState=t))}update(t=Math.min(this.clock.getDelta(),64/1e3)){if(!this.enabled||!this.camera||t===0)return;const{camera:e,cameraRadius:i,pivotPoint:o,up:n,state:l,adjustHeight:a}=this;e.updateMatrixWorld(),this.getCameraUpDirection(v),this._upInitialized||(this._upInitialized=!0,this.up.copy(v));const P=this._inertiaNeedsUpdate();if(this.needsUpdate||P){const h=this.zoomDelta;this._updateZoom(),this._updatePosition(t),this._updateRotation(t),l===k||l===T?(U.set(0,0,-1).transformDirection(e.matrixWorld),this.inertiaTargetDistance=d.copy(this.pivotPoint).sub(e.position).dot(U)):l===b&&this._updateInertia(t),(l!==b||h!==0||P)&&this.dispatchEvent(it),this.needsUpdate=!1}const s=e.isOrthographicCamera?null:a&&this._getPointBelowCamera()||null,p=e.isOrthographicCamera?o:s&&s.point||null;if(this.getCameraUpDirection(v),this._setFrame(v,p),(this.state===k||this.state===T)&&this.actionHeightOffset!==0){const{actionHeightOffset:h}=this;e.position.addScaledVector(n,-h),o.addScaledVector(n,-h),s&&(s.distance-=h)}if(this.actionHeightOffset=0,s){const h=s.distance;if(h<i){const r=i-h;e.position.addScaledVector(n,r),o.addScaledVector(n,r),this.actionHeightOffset=r}}this.pointerTracker.updateFrame()}adjustCamera(t){const{adjustHeight:e,cameraRadius:i}=this;if(t.isPerspectiveCamera){this.getUpDirection(t.position,v);const o=e&&this._getPointBelowCamera(t.position,v)||null;if(o){const n=o.distance;n<i&&t.position.addScaledVector(v,i-n)}}}dispose(){this.detach()}_updateInertia(t){const{rotationInertia:e,pivotPoint:i,dragInertia:o,enableDamping:n,dampingFactor:l,camera:a,cameraRadius:P,minDistance:s,inertiaTargetDistance:p}=this;if(!this.enableDamping||this.inertiaStableFrames>1){o.set(0,0,0),e.set(0,0,0);return}const h=Math.pow(2,-t/l),r=Math.max(a.near,P,s,p),c=.25*(2/(2*1e3));if(e.lengthSq()>0){z(u,d.set(0,0,-1),a),u.applyMatrix4(a.matrixWorldInverse),u.direction.normalize(),u.recast(-u.direction.dot(u.origin)).at(r/u.direction.z,d),d.applyMatrix4(a.matrixWorld),z(u,x.set(c,c,-1),a),u.applyMatrix4(a.matrixWorldInverse),u.direction.normalize(),u.recast(-u.direction.dot(u.origin)).at(r/u.direction.z,x),x.applyMatrix4(a.matrixWorld),d.sub(i).normalize(),x.sub(i).normalize();const D=d.angleTo(x)/t;e.multiplyScalar(h),(e.lengthSq()<D**2||!n)&&e.set(0,0)}if(o.lengthSq()>0){z(u,d.set(0,0,-1),a),u.applyMatrix4(a.matrixWorldInverse),u.direction.normalize(),u.recast(-u.direction.dot(u.origin)).at(r/u.direction.z,d),d.applyMatrix4(a.matrixWorld),z(u,x.set(c,c,-1),a),u.applyMatrix4(a.matrixWorldInverse),u.direction.normalize(),u.recast(-u.direction.dot(u.origin)).at(r/u.direction.z,x),x.applyMatrix4(a.matrixWorld);const D=d.distanceTo(x)/t;o.multiplyScalar(h),(o.lengthSq()<D**2||!n)&&o.set(0,0,0)}e.lengthSq()>0&&this._applyRotation(e.x*t,e.y*t,i),o.lengthSq()>0&&(a.position.addScaledVector(o,t),a.updateMatrixWorld())}_inertiaNeedsUpdate(){const{rotationInertia:t,dragInertia:e}=this;return t.lengthSq()!==0||e.lengthSq()!==0}_updateZoom(){const{zoomPoint:t,zoomDirection:e,camera:i,minDistance:o,maxDistance:n,pointerTracker:l,domElement:a,minZoom:P,maxZoom:s,zoomSpeed:p,state:h}=this;let r=this.zoomDelta;if(this.zoomDelta=0,!(!l.getLatestPoint(g)||r===0&&h!==O))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),i.isOrthographicCamera){this._updateZoomDirection();const _=this.zoomPointSet||this._updateZoomPoint();V.unproject(i);const f=Math.pow(.95,Math.abs(r*.05));let c=r>0?1/Math.abs(f):f;c*=p,c>1?s<i.zoom*c&&(c=1):P>i.zoom*c&&(c=1),i.zoom*=c,i.updateProjectionMatrix(),_&&(E(g.x,g.y,a,q),q.unproject(i),i.position.sub(q).add(V),i.updateMatrixWorld())}else{this._updateZoomDirection();const _=d.copy(e);if(this.zoomPointSet||this._updateZoomPoint()){const f=t.distanceTo(i.position);if(r<0){const c=Math.min(0,f-n);r=r*f*p*.0025,r=Math.max(r,c)}else{const c=Math.max(0,f-o);r=r*Math.max(f-o,0)*p*.0025,r=Math.min(r,c)}i.position.addScaledVector(e,r),i.updateMatrixWorld()}else{const f=this._getPointBelowCamera();if(f){const c=f.distance;_.set(0,0,-1).transformDirection(i.matrixWorld),i.position.addScaledVector(_,r*c*.01),i.updateMatrixWorld()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:t,raycaster:e,camera:i,zoomDirection:o,pointerTracker:n}=this;n.getLatestPoint(g),E(g.x,g.y,t,V),z(e,V,i),o.copy(e.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:t,zoomDirectionSet:e,zoomDirection:i,raycaster:o,zoomPoint:n,pointerTracker:l,domElement:a}=this;if(this._zoomPointWasSet=!1,!e)return!1;t.isOrthographicCamera&&l.getLatestPoint(A)?(E(A.x,A.y,a,A),z(o,A,t)):(o.ray.origin.copy(t.position),o.ray.direction.copy(i),o.near=0,o.far=1/0);const P=this._raycast(o);return P?(n.copy(P.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0):!1}_getPointBelowCamera(t=this.camera.position,e=this.up){const{raycaster:i}=this;i.ray.direction.copy(e).multiplyScalar(-1),i.ray.origin.copy(t).addScaledVector(e,1e5),i.near=0,i.far=1/0;const o=this._raycast(i);return o&&(o.distance-=1e5),o}_updatePosition(t){const{raycaster:e,camera:i,pivotPoint:o,up:n,pointerTracker:l,domElement:a,state:P,dragInertia:s}=this;if(P===k){if(l.getCenterPoint(g),E(g.x,g.y,a,g),J.setFromNormalAndCoplanarPoint(n,o),z(e,g,i),Math.abs(e.ray.direction.dot(n))<Z){const p=Math.acos(Z);R.crossVectors(e.ray.direction,n).normalize(),e.ray.direction.copy(n).applyAxisAngle(R,p).multiplyScalar(-1)}if(this.getUpDirection(o,v),Math.abs(e.ray.direction.dot(v))<j){const p=Math.acos(j);R.crossVectors(e.ray.direction,v).normalize(),e.ray.direction.copy(v).applyAxisAngle(R,p).multiplyScalar(-1)}e.ray.intersectPlane(J,d)&&(x.subVectors(o,d),i.position.add(x),i.updateMatrixWorld(),x.multiplyScalar(1/t),l.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(s.copy(x),this.inertiaStableFrames=0))}}_updateRotation(t){const{pivotPoint:e,pointerTracker:i,domElement:o,state:n,rotationInertia:l}=this;n===T&&(i.getCenterPoint(g),i.getPreviousCenterPoint(tt),F.subVectors(g,tt).multiplyScalar(2*Math.PI/o.clientHeight),this._applyRotation(F.x,F.y,e),F.multiplyScalar(1/t),i.getMoveDistance()/t<2*window.devicePixelRatio?this.inertiaStableFrames++:(l.copy(F),this.inertiaStableFrames=0))}_applyRotation(t,e,i){if(t===0&&e===0)return;const{camera:o,minAltitude:n,maxAltitude:l,rotationSpeed:a}=this,P=-t*a;let s=e*a;U.set(0,0,1).transformDirection(o.matrixWorld),this.getUpDirection(i,v),d.crossVectors(v,U).normalize(),X.set(1,0,0).transformDirection(o.matrixWorld).normalize();const h=Math.sign(d.dot(X))*v.angleTo(U);s>0?(s=Math.min(h-n-.01,s),s=Math.max(0,s)):(s=Math.max(h-l,s),s=Math.min(0,s)),M.setFromAxisAngle(v,P),L(i,M,C),o.matrixWorld.premultiply(C),R.set(-1,0,0).transformDirection(o.matrixWorld),M.setFromAxisAngle(R,s),L(i,M,C),o.matrixWorld.premultiply(C),o.matrixWorld.decompose(o.position,o.quaternion,d)}_setFrame(t,e){const{up:i,camera:o,state:n,zoomPoint:l,zoomDirectionSet:a,zoomPointSet:P,reorientOnDrag:s,scaleZoomOrientationAtEdges:p}=this;o.updateMatrixWorld(),M.setFromUnitVectors(i,t);const h=n;if(a&&(P||this._updateZoomPoint())){if(this.getUpDirection(l,d),p){let r=Math.max(d.dot(i)-.6,0)/.4;r=ft.mapLinear(r,0,.5,0,1),r=Math.min(r,1),o.isOrthographicCamera&&(r*=.1),M.slerp(vt,1-r)}L(l,M,C),o.matrixWorld.premultiply(C),o.matrixWorld.decompose(o.position,o.quaternion,d),this.zoomDirectionSet=!1,this._updateZoomDirection()}else h===k&&s&&e&&(L(e,M,C),o.matrixWorld.premultiply(C),o.matrixWorld.decompose(o.position,o.quaternion,d));i.copy(t),o.updateMatrixWorld()}_raycast(t){const{scene:e,useFallbackPlane:i,fallbackPlane:o}=this,n=t.intersectObject(e)[0]||null;if(n)return n;if(i){const l=o;if(t.ray.intersectPlane(l,d))return{point:d.clone(),distance:t.ray.origin.distanceTo(d)}}return null}}export{k as D,Dt as E,b as N,O as Z,E as a,_t as b,St as c,L as m,z as s};
